package ast

object Factorial {
  class Level0
  case object Class1Level1 extends Level0
  case object Class2Level1 extends Level0
  class Level1 extends Level0
  case object Class1Level2 extends Level1
  case object Class2Level2 extends Level1

def seqTest2(n: Int) = {
    if (n==1) 5L
    else if (n==2){
      6;      
      5+5
      seqTest2(9)      
    } else
    9.     
  }

  def seqTest(n: Int) = {
    if (n==1) 5L
    else if (n==2){
      6;
      {{
      5+5
      seqTest(9)
      }}
    } else
    9.     
  }

   def factorial(number: Int)  = {
    def factorialWithAccumulator(accumulator: Int, number: Int) = {
       if (number == 1) 
             accumulator
       else
           factorialWithAccumulator(accumulator * number, number - 1)
    }
   factorialWithAccumulator(1, number)
  } 

  def fact2(n: Int) = {
    n match {
      case 0 => 0
      case 1 => 2L
      case n => fact2(n - 1)
    }
  }

def pascal(column: Long, row: Long) = {
  type Point = (Long, Long)
  type Points = List[Point]
  type Triangle = Map[Point,Long]
  def above(p: Point) = (p._1, p._2 - 1)
  def aboveLeft(p: Point) = (p._1 - 1, p._2 - 1)
  
  def find(ps: Points, t: Triangle) = ps match {
    // Found the ultimate goal
    case (p :: Nil) if t contains p => t(p)
    // Found an intermediate point: pop the stack and carry on
    case (p :: rest) if t contains p => find(rest, t)
    // Hit a triangle edge, add it to the triangle
    case ((c, r) :: _) if (c == 0) || (c == r) => find(ps, t + ((c,r) -> 1))
    // Triangle contains (c - 1, r - 1)...
    case (p :: _) if t contains aboveLeft(p) => if (t contains above(p))
        // And it contains (c, r - 1)!  Add to the triangle
        find(ps, t + (p -> (t(aboveLeft(p)) + t(above(p)))))
      else
        // Does not contain(c, r -1).  So find that
        find(above(p) :: ps, t)
    // If we get here, we don't have (c - 1, r - 1).  Find that.
    case (p :: _) => find(aboveLeft(p) :: ps, t)
  }

  require(column >= 0 && row >= 0 && column <= row)
  (column, row) match {
    case (c, r) if (c == 0) || (c == r) => 1
    case p => find(List(p), Map())
  }
}



  def multipleCalls2(n: Int, g: String) = {
    if (n == 0) Class1Level2
    else if (n == 1 || n == 2) {
      if (n == 1) multipleCalls2(n - 1, "AAA")
      else Class1Level2
    } else if (n == 3) multipleCalls2(n - 1, "AAA")
    else Class2Level2
  }

  def multipleCalls12(n: Int, g: String) = {
    if (n == 0) Class1Level1
    else if (n == 1 || n == 2) {
      if (n == 1) multipleCalls12(n - 1, "AAA")
      else Class1Level2
    } else if (n == 3) multipleCalls12(n - 1, "AAA")
    else Class2Level1
  }

  def level12If(n: Int, g: String) = {
    if (n == 0) Class1Level1
    else if (n == 1 || n == 2) {
      if (n == 1) level12If(n - 1, "AAA")
      else Class1Level2
    } else if (n == 3) Class1Level1
    else Class1Level1
  }

  def level12IfMatch(n: Int) = {
    if (n == 0) Class1Level1
    else if (n == 1 || n == 2) {
      n match {
        case 1 => level12IfMatch(n - 1)
        case 2 => Class1Level2
      }
    } else if (n == 3) Class1Level1
    else Class1Level1
  }
   
  def level2IfMatch(n: Int) = {
    if (n == 0) Class1Level2
    else if (n == 1 || n == 2) {
      n match {
        case 1 => level2IfMatch(n - 1)
        case 2 => Class2Level2
      }
    } else if (n == 3) Class1Level2
    else Class1Level2
  }

  def factIf(n: Int) = {
    if (n == 0) 0L
    else if (n == 1) 2.
    else if (n == 3) 6
    else factIf(n - 1)
  }

  def fact(n: Int): Long = {
    n match {
      case 0 => 0
      case 1 => 2L
      case n => fact(n - 1)
    }
  }

  def somethingHarder(n: Int) = {
    n match {
      case 0 => 0.
      case 1 => 2L
      case n => somethingHarder(n - 1)
    }
  }

  def level1(n: Int) = {
    n match {
      case 0 => Class1Level1
      case 1 => Class2Level1
      case n => level1(n - 1)
    }
  }

  def level2(n: Int) = {
    n match {
      case 0 => Class1Level2
      case 1 => Class2Level2
      case n => level2(n - 1)
    }
  }

  def level12(n: Int, g: String) = {
    n match {
      case 0 => Class1Level2
      case 1 => Class1Level1
      case n => level12(n - 1, "AAA")
    }
  }
   
}
